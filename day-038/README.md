## Day 38: DNS Resolution - CoreDNS Breakdown

## THE IDEA:
Break DNS resolution by misconfiguring CoreDNS, exhausting its resources, or creating
search domain loops. Watch services become unreachable despite being healthy.

## THE SETUP:
Deploy apps that rely on DNS, break CoreDNS configuration, trigger query timeouts,
and test ndots behavior that multiplies DNS queries.

## WHAT I LEARNED:
- CoreDNS runs as pods (can be killed/scaled)
- ndots=5 causes search domain explosion
- DNS queries are cached (30s TTL default)
- Pod DNS uses /etc/resolv.conf generated by kubelet
- NetworkPolicy can block DNS to kube-system

## WHY IT MATTERS:
DNS failures cause:
- Intermittent connection failures to services
- Slow application startup (DNS timeouts)
- Cascading failures across microservices

## TRY IT:
ðŸ§ª Interactive Lab: https://killercoda.com/chadmcrowell/course/kubeskills-daily/day-038

Tomorrow: Resource contention and QoS eviction priorities.

## TRY IT:
ðŸ§ª Interactive Lab: https://killercoda.com/playgrounds/scenario/kubernetes


---

# Killercoda Lab Instructions


## Step 1: Check CoreDNS pods
```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
kubectl get service -n kube-system kube-dns
```

## Step 2: Test basic DNS resolution
```bash
kubectl run dnstest --rm -it --restart=Never --image=busybox -- nslookup kubernetes.default
```

Should resolve to ClusterIP of kubernetes service.

## Step 3: Check pod DNS configuration
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: dns-check
spec:
  containers:
  - name: test
    image: busybox
    command: ['sleep', '3600']
EOF

kubectl exec dns-check -- cat /etc/resolv.conf
```

Shows:
- nameserver (CoreDNS ClusterIP)
- search domains
- ndots (usually 5)

## Step 4: Scale CoreDNS to 0 (break DNS!)
```bash
kubectl scale deployment coredns -n kube-system --replicas=0

# Wait a moment
sleep 5

# Try DNS resolution
kubectl run dnstest2 --rm -it --restart=Never --image=busybox -- nslookup kubernetes.default 2>&1 || echo "DNS failed!"
```

Times out! No CoreDNS pods running.

## Step 5: Restore CoreDNS
```bash
kubectl scale deployment coredns -n kube-system --replicas=2

# Wait for pods
kubectl wait --for=condition=Ready pods -l k8s-app=kube-dns -n kube-system --timeout=60s

# Test again
kubectl run dnstest3 --rm -it --restart=Never --image=busybox -- nslookup kubernetes.default
```

Works again!

## Step 6: Test ndots search domain expansion
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: ndots-test
spec:
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c']
    args:
    - |
      echo "=== Resolving 'kubernetes' (short name) ==="
      time nslookup kubernetes
      echo ""
      echo "=== Resolving 'kubernetes.default.svc.cluster.local' (FQDN) ==="
      time nslookup kubernetes.default.svc.cluster.local
      sleep 3600
EOF
```

**Check output:**
```bash
kubectl logs ndots-test
```

Short name tries ALL search domains first (slow)!

## Step 7: Reduce ndots to optimize
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: ndots-optimized
spec:
  dnsConfig:
    options:
    - name: ndots
      value: "1"
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'cat /etc/resolv.conf; nslookup kubernetes; sleep 3600']
EOF
```

**Check resolv.conf:**
```bash
kubectl exec ndots-optimized -- cat /etc/resolv.conf
```

Shows ndots:1

## Step 8: Test DNS timeout configuration
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: dns-timeout
spec:
  dnsConfig:
    options:
    - name: timeout
      value: "1"
    - name: attempts
      value: "2"
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c']
    args:
    - |
      cat /etc/resolv.conf
      nslookup nonexistent.example.com 2>&1 || echo "Failed fast"
      sleep 3600
EOF
```

**Check logs:**
```bash
kubectl logs dns-timeout
```

Fails quickly with timeout:1, attempts:2

## Step 9: Test dnsPolicy variations
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: dns-default
spec:
  dnsPolicy: Default  # Use node's /etc/resolv.conf
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'cat /etc/resolv.conf; sleep 3600']
---
apiVersion: v1
kind: Pod
metadata:
  name: dns-clusterfirst
spec:
  dnsPolicy: ClusterFirst  # Use cluster DNS (default)
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'cat /etc/resolv.conf; sleep 3600']
---
apiVersion: v1
kind: Pod
metadata:
  name: dns-none
spec:
  dnsPolicy: None  # Custom only
  dnsConfig:
    nameservers:
    - 8.8.8.8
    - 8.8.4.4
    searches:
    - custom.local
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'cat /etc/resolv.conf; sleep 3600']
EOF
```

**Compare configs:**
```bash
echo "=== Default ==="
kubectl exec dns-default -- cat /etc/resolv.conf
echo "=== ClusterFirst ==="
kubectl exec dns-clusterfirst -- cat /etc/resolv.conf
echo "=== None ==="
kubectl exec dns-none -- cat /etc/resolv.conf
```

## Step 10: Test CoreDNS ConfigMap
```bash
kubectl get configmap coredns -n kube-system -o yaml
```

**Add custom domain:**
```bash
kubectl edit configmap coredns -n kube-system
# Add under ".:53" section:
#   hosts {
#     192.168.1.100 custom.example.com
#     fallthrough
#   }
```

**Reload CoreDNS:**
```bash
kubectl rollout restart deployment coredns -n kube-system
kubectl wait --for=condition=Ready pods -l k8s-app=kube-dns -n kube-system --timeout=60s
```

## Step 11: Test DNS caching
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: cache-test
spec:
  selector:
    app: cache-test
  ports:
  - port: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cache-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cache-test
  template:
    metadata:
      labels:
        app: cache-test
    spec:
      containers:
      - name: app
        image: nginx
EOF
```

**Resolve multiple times:**
```bash
kubectl run resolver --rm -it --restart=Never --image=busybox -- sh -c '
for i in $(seq 1 5); do
  echo "Query $i:"
  nslookup cache-test
  sleep 1
done
'
```

Queries are cached!

## Step 12: Test NetworkPolicy blocking DNS
```bash
cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: block-dns
spec:
  podSelector:
    matchLabels:
      app: dns-blocked
  policyTypes:
  - Egress
  egress:
  - to:
    - podSelector: {}
---
apiVersion: v1
kind: Pod
metadata:
  name: dns-blocked
  labels:
    app: dns-blocked
spec:
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'nslookup kubernetes.default; sleep 3600']
EOF
```

**Check logs:**
```bash
kubectl logs dns-blocked 2>&1
```

Timeout! NetworkPolicy blocks DNS egress to kube-system.

## Step 13: Fix NetworkPolicy to allow DNS
```bash
kubectl delete networkpolicy block-dns

cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
spec:
  podSelector:
    matchLabels:
      app: dns-blocked
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
  - to:
    - podSelector: {}
EOF
```

**Restart pod:**
```bash
kubectl delete pod dns-blocked
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: dns-blocked
  labels:
    app: dns-blocked
spec:
  containers:
  - name: test
    image: busybox
    command: ['sh', '-c', 'nslookup kubernetes.default; echo "Success!"; sleep 3600']
EOF
```

Works now!

## Step 14: Test CoreDNS resource limits
```bash
# Check current resources
kubectl get deployment coredns -n kube-system -o yaml | grep -A 10 resources

# Monitor CoreDNS metrics
kubectl top pods -n kube-system -l k8s-app=kube-dns
```

## Step 15: Test headless service DNS
```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: headless-svc
spec:
  clusterIP: None
  selector:
    app: headless
  ports:
  - port: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: headless
spec:
  replicas: 3
  selector:
    matchLabels:
      app: headless
  template:
    metadata:
      labels:
        app: headless
    spec:
      containers:
      - name: app
        image: nginx
EOF
```

**Resolve headless service:**
```bash
kubectl run resolver2 --rm -it --restart=Never --image=busybox -- nslookup headless-svc
```

Returns multiple pod IPs (not single ClusterIP)!

## Key Observations

âœ… **CoreDNS pods** - can be scaled, killed, or resource-starved
âœ… **ndots=5** - causes search domain expansion (slow)
âœ… **DNS caching** - 30s default TTL
âœ… **NetworkPolicy** - can block DNS if not explicitly allowed
âœ… **dnsPolicy** - controls which nameservers to use
âœ… **Headless services** - return pod IPs directly

## Production Patterns

**Optimized DNS config:**
```yaml
spec:
  dnsPolicy: ClusterFirst
  dnsConfig:
    options:
    - name: ndots
      value: "2"  # Reduce search domain tries
    - name: timeout
      value: "2"
    - name: attempts
      value: "2"
```

**Always allow DNS in NetworkPolicies:**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
```

**Scale CoreDNS for large clusters:**
```bash
# Horizontal scaling
kubectl scale deployment coredns -n kube-system --replicas=5

# Vertical scaling
kubectl set resources deployment coredns -n kube-system \
  --limits=cpu=200m,memory=256Mi \
  --requests=cpu=100m,memory=128Mi
```

**Custom CoreDNS config:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    .:53 {
        errors
        health {
           lameduck 5s
        }
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
           ttl 30
        }
        prometheus :9153
        forward . /etc/resolv.conf {
           max_concurrent 1000
        }
        cache 30
        loop
        reload
        loadbalance
    }
```

## Cleanup
```bash
kubectl delete pod dns-check ndots-test ndots-optimized dns-timeout dns-default dns-clusterfirst dns-none dns-blocked 2>/dev/null
kubectl delete networkpolicy allow-dns 2>/dev/null
kubectl delete deployment cache-test headless 2>/dev/null
kubectl delete service cache-test headless-svc 2>/dev/null
```

---
